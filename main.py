import random

import tsplib95

#import numpy as np
import pandas as pd
import matplotlib.pyplot as plt

population_size = 100
nr_of_generations = 200

# (mu) percentage of parents selected
survival_ratio = 0.25

# (lambda) percentage of children generated by parents
reproduction_type_ratio = 0.3

mutation_probability = 0.1

#df=pd.read_excel('problems/berlin52.xlsx', index_col=None, header=None)    #   <----------- here distance matrix input
#adjacency_mat=df.values.tolist()
#distance_matrix=np.asarray(adjacency_mat)
    
best_fitness_values = []


def generate_tsp_map():
    city_list = tsp.node_coords

    for i in range(1, len(city_list)):
        distance_to_i = []
        for j in range(1, len(city_list)):
            distance_to_i.append(tsplib95.distances.euclidean(city_list[i], city_list[j]))
        tsp_map.append(distance_to_i)

    return tsp_map


def generate_initial_population():
    population = []
    for _ in range(population_size):
        population.append(Individual())
    return population


def generation(population):
    population.sort(key=lambda x: x.cost)

    survivors = int(len(population) * survival_ratio)
    number_of_children = len(population) - survivors

    number_of_parent_children = int(number_of_children * reproduction_type_ratio)
    number_of_cloned_children = number_of_children - number_of_parent_children

    # clone
    for i in range(number_of_cloned_children):
        population[survivors + i] = population[random.choice(range(survivors))].reproduce()

    # cross
    for i in range(number_of_children - number_of_cloned_children):
        population[survivors + i + number_of_cloned_children] = population[random.choice(range(survivors))].reproduce(
            population[random.choice(range(survivors))])
    return population


def find_best_individual(population):
    best_individual = population[0]
    for individual in population:
        if individual.cost < best_individual.cost:
            best_individual = individual
    best_fitness_values.append(best_individual.cost)
    return best_individual


class Individual:
    gene = list()

    def __init__(self, gene=None):
        if gene is None:
            self.gene = self.create()
        else:
            if len(gene) != number_of_cities:
                raise Exception
            self.gene = gene
        self.cost = self.evaluate()

    @staticmethod
    def create():
        created_list = list(range(number_of_cities))
        random.shuffle(created_list)
        return created_list

    def reproduce(self, partner=None):
        if partner is None:
            child = self
        else:
            child = self.cross_over(partner)

        if random.random() < mutation_probability:
            child = child.mutate()

        return child

    # mutation
    def mutate(self):
        cut1 = random.choice(range(number_of_cities - 2))
        cut2 = (random.choice(range(number_of_cities - 2 - cut1))) + cut1 + 2
        reverse_part = self.gene[cut1:cut2 + 1][::-1]
        new_gene = self.gene[:cut1] + reverse_part + self.gene[cut2 + 1:]

        return Individual(new_gene)

    # edge recombination crossover
    def cross_over(self, partner):
        child_gene = []

        # Construct neighbor lists
        neighbor_sets = [set() for _ in range(number_of_cities)]
        for i in range(number_of_cities):
            # Add the neighbors of the first city, according to parents
            if i == 0:
                neighbor_sets[i].add(self.gene.index(number_of_cities - 1))
            elif i == number_of_cities - 1:
                neighbor_sets[i].add(self.gene.index(0))
            else:
                neighbor_sets[i].add(self.gene.index(i - 1))
                neighbor_sets[i].add(self.gene.index(i + 1))
                neighbor_sets[i].add(partner.gene.index(i - 1))
                neighbor_sets[i].add(partner.gene.index(i + 1))

        # Take the first city of one of the parents
        city = self.gene[0]

        # Pick an edge from that city from one of the parents
        while len(child_gene) < number_of_cities:

            child_gene.append(city)
            for i in neighbor_sets:
                i.discard(city)

            if bool(neighbor_sets[city]):
                min = number_of_cities
                for i in neighbor_sets[city]:
                    if len(neighbor_sets[i]) < min:
                        min = len(neighbor_sets[i])
                        city = i

            else:
                difference = set(range(number_of_cities)) - (set(child_gene))
                if len(difference) > 0:
                    city = difference.pop()

        child = Individual(child_gene)
        return child

    def evaluate(self):
        cost = 0
        for i in range(number_of_cities - 1):
            cost += tsp_map[self.gene[i]][self.gene[i + 1]]
        cost += tsp_map[self.gene[number_of_cities - 1]][self.gene[0]]
        return cost


def run_evolutionary_algorithm():
    if population_size < 2:
        print("Reproducing solo doesn't work")
        exit()
    population = generate_initial_population()
    best = find_best_individual(population)
    print(f"Best solution in population 1: length: {best.cost}, solution: {best.gene}")
    for i in range(nr_of_generations - 1):
        population = generation(population)
        best = find_best_individual(population)
        print(f"Best solution in population {i + 2}: length: {best.cost}, solution: {best.gene}")
    return find_best_individual(population)


if __name__ == "__main__":
    # best known solution for att48 = 10628
    # tsp = tsplib95.load('problems/att48.tsp')
    # best known solution for berlin52 = 7542
    tsp = tsplib95.load('problems/berlin52.tsp')
    
    output_file = 'TSP_Solution_Lengths.xlsx'

    tsp_map = []
    generate_tsp_map()
    number_of_cities = len(tsp_map)
    solution = run_evolutionary_algorithm()
    print("Best solution found has length: " + str(solution.cost) + ", solution: " + str(solution.gene))
    
    
    if output_file:
        df_output = pd.DataFrame({'Population': range(len(best_fitness_values)), 'Fitness': best_fitness_values})
        df_output.to_excel(output_file, index=False)

    plt.plot(best_fitness_values)
    plt.xlabel("Population")
    plt.ylabel("Fitness")
    plt.title("Convergence Plot")
    plt.show()
